"use strict";(self.webpackChunkdev_portal=self.webpackChunkdev_portal||[]).push([[4427],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=d(e,["components","mdxType","originalType","parentName"]),m=p(n),u=r,h=m["".concat(l,".").concat(u)]||m[u]||s[u]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var d={};for(var l in t)hasOwnProperty.call(t,l)&&(d[l]=t[l]);d.originalType=e,d.mdxType="string"==typeof e?e:r,i[1]=d;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9845:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return d},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return c},default:function(){return m}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],d={title:"Run in Production",sidebar_position:4},l=void 0,p={unversionedId:"provider/daemon/getting_started/run_prod",id:"provider/daemon/getting_started/run_prod",isDocsHomePage:!1,title:"Run in Production",description:"Whether you're serving your daemon as a standalone binary or as a dockerized solution, if you want to do that on a remote machine you have to go through some further steps to interact with it, especially if you want to make its Operator interface reachable from the outside world.",source:"@site/docs/provider/daemon/getting_started/run_prod.md",sourceDirName:"provider/daemon/getting_started",slug:"/provider/daemon/getting_started/run_prod",permalink:"/docs/provider/daemon/getting_started/run_prod",editUrl:"https://github.com/tdex-network/dev-portal/edit/master/docs/provider/daemon/getting_started/run_prod.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Run in Production",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Run Standalone",permalink:"/docs/provider/daemon/getting_started/run_standalone"},next:{title:"Configure CLI",permalink:"/docs/provider/daemon/getting_started/configure_cli"}},c=[{value:"Enable macaroons/TLS for Operator interface on remote host",id:"enable-macaroonstls-for-operator-interface-on-remote-host",children:[]},{value:"Enable TLS or Onion for Trade interface on remote host",id:"enable-tls-or-onion-for-trade-interface-on-remote-host",children:[{value:"Enable TLS for Trade interface",id:"enable-tls-for-trade-interface",children:[]},{value:"Enable Onion for Trade interface",id:"enable-onion-for-trade-interface",children:[]}]},{value:"Configure a local Operator CLI to connect with remote daemon",id:"configure-a-local-operator-cli-to-connect-with-remote-daemon",children:[]},{value:"Auto-Unlock Wallet on start-up",id:"auto-unlock-wallet-on-start-up",children:[]}],s={toc:c};function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Whether you're serving your daemon as a standalone binary or as a dockerized solution, if you want to do that on a remote machine you have to go through some further steps to interact with it, especially if you want to make its Operator interface reachable from the outside world."),(0,o.kt)("p",null,"Here below, you can find the necessary info and examples to:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#enable-macaroonstls-for-operator-interface-on-remote-host"},"Enable macaroons/TLS for Operator interface on remote host")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#enable-tls-or-onion-for-trade-interface-on-remote-host"},"Enable TLS or Onion for Trade interface on remote host"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#enable-tls-for-trade-interface"},"Enable TLS for Trade interface")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#enable-onion-for-trade-interface"},"Enable Onion for Trade interface")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#configure-a-local-operator-cli-to-connect-with-remote-daemon"},"Configure a local Operator CLI to connect with remote daemon"))),(0,o.kt)("h2",{id:"enable-macaroonstls-for-operator-interface-on-remote-host"},"Enable macaroons/TLS for Operator interface on remote host"),(0,o.kt)("p",null,"If you want to run a daemon on a remote machine and make its Operator interface reachable from the outside world it's strongly suggested to enable macaroons auth and TLS encryption to secure the connection with external clients. "),(0,o.kt)("p",null,"You must have a static IP or a DNS name at which to reach your machine and configure it to allow in-going and out-going traffic over the Operator and Trade ports (the defaults are ",(0,o.kt)("inlineCode",{parentName:"p"},"9000")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"9945")," respctively)."),(0,o.kt)("p",null,"Before starting the daemon, export the environment variables ",(0,o.kt)("inlineCode",{parentName:"p"},"TDEX_OPERATOR_EXTRA_IP")," and/or ",(0,o.kt)("inlineCode",{parentName:"p"},"TDEX_OPERATOR_EXTRA_DOMAIN")," like for example:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Standalone:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ export TDEX_OPERATOR_EXTRA_IP=54.170.20.39\n$ export TDEX_OPERATOR_EXTRA_DOMAIN=provider.mydomain.network\n\n# Start a daemon with macaroons/TLS enabled ONLY on Operator interface\n$ tdexd\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Docker:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"# Start a dockerized daemon with macaroons/TLS enabled ONLY on Operator interface\n$ docker run -it -d \\\n  --name tdexd \\\n  --restart unless-stopped \\\n  -p 9945:9945 -p 9000:9000 \\\n  -v `pwd`/tdexd:/home/tdex/.tdex-daemon \\\n  -e TDEX_OPERATOR_EXTRA_IP=54.170.20.39 \\\n  -e TDEX_OPERATOR_EXTRA_DOMAIN=provider.mydomain.network \\\n  ghcr.io/tdex-network/tdexd:latest\n")))),(0,o.kt)("p",null,"This will make the daemon create the TLS certificate by including the given IP/DNS name to the list of identities, making it usable for external clients."),(0,o.kt)("h2",{id:"enable-tls-or-onion-for-trade-interface-on-remote-host"},"Enable TLS or Onion for Trade interface on remote host"),(0,o.kt)("p",null,"To secure the connection with the Trade interface of your daemon, depending on your needs, you can opt for TLS encryption or spinnig up a Onion hidden service."),(0,o.kt)("h3",{id:"enable-tls-for-trade-interface"},"Enable TLS for Trade interface"),(0,o.kt)("p",null,"It is possible to enable TLS encryption and requiring to establish a secure connection with the public Trade interface of the daemon."),(0,o.kt)("p",null,"For this, you must obtain a valid TLS certificate from a trusted Certificate Authotity (for example ",(0,o.kt)("a",{parentName:"p",href:"https://letsencrypt.org/"},"Let's Encrypt"),", ",(0,o.kt)("a",{parentName:"p",href:"https://zerossl.com/"},"ZeroSSL"),", etc.) and export the ",(0,o.kt)("inlineCode",{parentName:"p"},"TDEX_SSL_KEY")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"TDEX_SSL_CERT")," environment variables with the paths of your TLS key and cert files:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Standalone:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"# In this example the TLS key/cert were previously generated with the help of\n# Let's Encrypt and placed in a dedicated directory into the daemon datadir\n$ export TDEX_SSL_KEY=~/.tdex-daemon/trade-tls/privatekey.pem\n$ export TDEX_SSL_CERT=~/.tdex-daemon/trade-tls/fullchain.pem\n\n# Start a daemon with TLS enabled ONLY on Trade interface\n$ tdexd\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Docker:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"# Start a dockerized daemon with TLS enabled ONLY on Trade interface\n$ docker run -it -d \\\n--name tdexd \\\n--restart unless-stopped \\\n-p 9945:9945 -p 9000:9000 \\\n-v `pwd`/tdexd:/.tdex-daemon \\\n# Here, it's required to mount the filepaths of the TLS key/cert as volumes\n# of the container\n-v `pwd`/privatekey.pem:/privatekey.pem \\\n-v `pwd`/fullchain.pem:/fullchain.pem \\\n-e TDEX_SSL_KEY=/privatekey.pem \\\n-e TDEX_SSL_CERT=/fullchain.pem \\\nghcr.io/tdex-network/tdexd:latest\n")))),(0,o.kt)("h3",{id:"enable-onion-for-trade-interface"},"Enable Onion for Trade interface"),(0,o.kt)("p",null,"If your daemon remote host uses a linux system, instead of enabling TLS on the Trade interface, you can alternatively run a Tor hidden service acting as a proxy in front of it."),(0,o.kt)("p",null,"If you opted for a dockerized solution, doing so is as simple as starting a container:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'#\xa0If you already have an onion key you can use it by exporting env var,\n#\xa0otherwise just skip this step.\n$ export ONION_KEY=<your_oniion_key_as_base64>\n\n# Start a tor hidden service that proxies incoming traffic on HTTP port to\n#\xa0daemon Trade interface on port 9945.\n$ docker -d \\\n    run --name tor \\\n    --network <network_with_tdexd_running>\n    --restart unless_stopped \\\n    -e TDEX_TOR_SERVICE_HOSTS="80:tdexd:9945" \\\n    -e TDEX_TOR_SERVICE_VERSION="3" \\\n    -e TDEX_TOR_SERVICE_KEY=${ONION_KEY} \\\n    goldy/tor-hidden-service:latest\n')),(0,o.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"To easily orchestrate multiple containers inter-connected to each other, you might find ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"https://github.com/tdex-network/tdex-box"},"TDEX Box"))," as an interesting solution for this purpose. Rather than having to run each container manually, it simplifies the process to editing a YAML configuration file and running a single command to spin up multiple containers (it is essentially a ",(0,o.kt)("a",{parentName:"p",href:"https://docs.docker.com/compose/"},"docker-compose")," file)."))),(0,o.kt)("h2",{id:"configure-a-local-operator-cli-to-connect-with-remote-daemon"},"Configure a local Operator CLI to connect with remote daemon"),(0,o.kt)("p",null,"Now that your daemon is up and running on your remote machine, if you made your Operator interface reachable, you can safely interact with it with the CLI on your laptop or home pc."),(0,o.kt)("p",null,"To do this, you need to import in your local machine a copy of both the macaroon named ",(0,o.kt)("inlineCode",{parentName:"p"},"admin.macaroon")," and the TLS certificate named ",(0,o.kt)("inlineCode",{parentName:"p"},"cert.pem")," that you can find in the daemon's datadir. If, for example you have SSH access to the remote host you can take advantage of the ",(0,o.kt)("inlineCode",{parentName:"p"},"scp")," command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ scp ubuntu@provider.mydomain.network:~/.tdex-daemon/macaroons/admin.macaroon ~/.tdex-daemon-remote/admin.macaroon\n$ scp ubuntu@provider.mydomain.network:~/.tdex-daemon/tls/cert.pem ~/.tdex-daemon-remote/cert.pem\n")),(0,o.kt)("p",null,"Now you're ready to properly configure the local Operator CLI to connect to the remote daemon:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ tdex config init --macaroons_path ./admin.macaroon --tls_cert_path ./cert.pem --rpc_address provider.mydomain.network:9000\n")),(0,o.kt)("p",null,"That's it! About time for you to ",(0,o.kt)("a",{parentName:"p",href:"/docs/provider/daemon/init_daemon"},"initialize your daemon with a seed and password"),"."),(0,o.kt)("h2",{id:"auto-unlock-wallet-on-start-up"},"Auto-Unlock Wallet on start-up"),(0,o.kt)("p",null,"Daemon's wallet can be unlocked, once initialized and (re)started, by providing file path, that contains password, to the daemon through environment variable."),(0,o.kt)("p",null,"Create password file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'$ echo "mypassword" > pwd.txt\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Standalone:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ export TDEX_WALLET_UNLOCK_PASSWORD_FILE=./pwd.txt\n$ tdexd\n"))),(0,o.kt)("li",{parentName:"ul"},"Docker:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ docker run -it -d \\\n--name tdexd \\\n--restart unless-stopped \\\n-p 9945:9945 -p 9000:9000 \\\n-v `pwd`/tdexd:/.tdex-daemon \\\n# Set env var of password file\n-e TDEX_WALLET_UNLOCK_PASSWORD_FILE:./pwd.txt \\\n# Here, it's required to mount the filepath of password file\n-v `pwd`/pwd.txt:/pwd.txt \\\nghcr.io/tdex-network/tdexd:latest\n")))))}m.isMDXComponent=!0}}]);